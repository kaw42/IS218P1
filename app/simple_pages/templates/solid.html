{% extends "base.html" %}
<!doctype html>
<html lang="en">
{% block content %}
    <body style="background-color:linen ;">
    <h1>How the Calculator demonstrates SOLID and identifies the use of design patterns</h1>
    <h4>
        What is SOLID?<br>
    </h4>
    <p class="tab">
        S - Single-responsiblity Principle: A class should have one and only one reason to change, meaning that a class
        should have only one job.<br>
        O - Open-closed Principle: Objects or entities should be open for extension but closed for modification.<br>
        L - Liskov Substitution Principle: Let q(x) be a property provable about objects of x of type T. Then q(y)
        should be provable for objects y of type S where S is a subtype of T.<br>
        I - Interface Segregations Principle: A client should never be forced to implement an interface that it doesn’t
        use, or clients shouldn’t be forced to depend on methods they do not use.<br>
        D - Dependency Inversion Principle: Entities must depend on abstractions, not on concretions. It states that the
        high-level module must not depend on the low-level module, but they should depend on abstractions.<br>
    </p>
    <h4>How does the calculator demonstrate SOLID? </h4>
    <p>
        S - Single-responsiblity Principle: In the calculator program, in operations\_init_.py, the classes Addition,
        Subtraction, and Multiplication each only have one job; to add, subtract, and multiply.<br>
        O - Open-closed Principle: In calculator, the source code for Addition, Subtraction, and Multiplication were
        extended to calculator\_init_.py without modifying the original code. <br>
        L - Liskov Substitution Principle: The principle defines that objects of a superclass shall be replaceable with
        objects of its subclasses without breaking the application. In calculator, the objects of the Calculator class
        were replaced with the objects of the Addition, Subtraction, and Multiplication Classes. <br>
        I - Interface Segregation Principle: Essentially, no code should be forced to depend on methods it does not use.
        In _init_.py, the code only uses methods that are necessary in order to make the calculator run properly.<br>
        D - Dependency Inversion Principle: Abstraction is demonstrated in the Calculator program because in
        calculator\_init_.py, the classes for Addition, Subtraction, and Multiplaction are called without showing the
        details of the contents for those classes. Although the methods from those classes are being used, you don't see
        what those methods actually do while looking at calculator\_init_.py. This is because the source code is in
        operations\_init_.py. <br>

    </p>
    <h4>Overview of Design Patterns</h4>
    <p>
        In software engineering, a design pattern is a general repeatable solution to a commonly occurring problem in
        software design. A design pattern isn't a finished design that can be transformed directly into code. It is a
        description or template for how to solve a problem that can be used in many different situations.
    </p>
    <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design">https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design</a>


    </body>
{% endblock %}
</html>